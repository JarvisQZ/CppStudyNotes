[toc]
# 12.动态内存

## 12.0 补充知识
1. 堆内存和栈内存的比较：
   - 栈由编译器自动分配和释放
   - 堆由程序员分配和释放
2. 空间大小
   - 栈：windows下，栈是向低地址扩展的，是连续的内存区域，所以栈顶地址和栈的最大容量都是确定的，似乎一般是2M或1M
   - 堆：堆是向高内存地址扩展的，是不连续的内存区域，系统是用链表来存储空闲地址的，堆的大小由计算机的有效虚拟内存决定，空间大很多
3. 分配效率
   - 栈：速度较快
   - 堆：速度较慢，但是用方便
4. 系统响应
   - 栈：如果剩余空间不足，异常提示栈溢出
   - 堆：在记录空闲地址的链表中寻址空间大于申请空间的堆节点，然后将该节点从空间节点链表中删除，一般会在首地址处记录本次分配空间的大小
5. 存储内容
   - 栈：存储函数的各个参数，局部变量，函数返回地址等。第一个进栈的就是函数返回地址
   - 堆：内容由程序员决定

## 12.1 动态内存与智能指针
c++ 使用new和delete管理动态内存
- new 在堆中为对象分配空间并返回指向该对象的指针
- delete 接受一个动态对象的指针，销毁该对象并释放内存

忘记释放内存会引起内存泄漏，释放了后继续引用指针会引用非法内存
如果忘记释放内存，在程序结束时会由操作系统自动回收。
新标准库提供两种智能指针和一个班队类管理动态内存，都定义在头文件 memory 中
1. shared_ptr: 允许多个指针指向同一对象
2. unique_ptr：独占所指的对象
3. weak_ptr：一种弱引用，指向 shared_ptr 所管理的对象
要注意到，智能指针实际上是一个类模板，但是他的操作与指针十分类似

### 12.1.1 shared_ptr类
智能指针也是模板，类似 vector。在创建模板时，必须提供指针指向的类型。
```c++
shared_ptr<string> p1;       // 可以指向 string
shared_ptr<vector<int>> p2;  // 可以指向 int 的 vector
```
默认初始化的智能指针中保存着空指针

`定义 shared_ptr 的方式`
可以使用另一个 shared_ptr 或一个 unique_ptr 或 new 的指针来初始化一个 shared_ptr。
```c++
shared_ptr<int> p;              // 默认初始化为空指针
shared_ptr<int> p(q);           // q 也是一个 shared_ptr,p 是 q 的拷贝，此操作会递增 q 中的计数器。
shared_ptr<int> p(qnew);        // qnew 是一个指向动态内存的内置指针（qnew = new int;)）
shared_ptr<int> p(u);           // u 是一个 unique_ptr。p 从 u 接管了对象的所有权，u 被置为空
shared_ptr<int> p(q, deleter);  // q 是一个内置指针。p 将使用可调用对象 deleter 来代替 delete
shared_ptr<int> p(p2, deleter); // p2 是一个 shared_ptr，p 是 p2 的拷贝，唯一的区别是 p 将可调用对象 d 来代替 delete。

auto p = make_shared<int>(10);  //返回一个 shared_ptr，指向一个初始化为 10 的动态分配的 int 对象。注意不同于 make_pair
```

shared_ptr 操作
```c++
sp              // 智能指针作为 if 的判断条件时检查其是否为空，若 sp 指向一个对象，则为 true
sp->mem;        // 等价于 (*p).mem。用于当 sp 指向一个类时
sp.get();       // 返回 sp 中保存的指针。要小心使用！
swap(p, q);     // 交换 p 和 q 中的指针
p.swap(q);      // 同上

p = q;          // 此操作会递增 q 中的计数器，递减 p 原来的计数器，若其变为 0，则释放。
p.unique();     // 若 p.use_count() 为 1，返回 true，否则返回 false
p.use_count();  // 返回与 p 共享对象的智能指针数量。可能运行很慢，主要用于调试

p.reset();     // 将 p 置为空，如果 p 计数值为 1，释放对象。
p.reset(q);    // q 是一个内置指针，令 p 指向 q。
p.reset(q, d); // 调用可调用对象 d 而不是 delete 来释放 q
```

`make_shared 函数`
这是最安全的分配和使用动态内存的方法
make_shared 类似顺序容器的 emplace 成员，用参数来构造对象。
通常用 auto 来定义一个对象保存 make_shared 的结果。
make_shared 是函数模板，要提供模板参数
```c++
shared_ptr<int> p1 = make_shared<int>(10);
auto p2 = make_shared<string>(10,'s');
```

`shared_ptr 自动销毁所管理的对象`

shared_ptr 通过析构函数来完成销毁。

它的析构函数会递减对象的引用计数，如果计数变为 0，则销毁对象并释放内存。

shared_ptr 自动释放相关联的内存

由于最后一个 shared_ptr 销毁前内存都不会释放，所以要保证 shared_ptr 无用之后就不要再保留了。

如果忘记销毁不再需要的 shared_ptr，程序不会出错，但会浪费内存。

一种常量的情况是将 shared_ptr 存放在一个容器中，后来其中有一部分元素不再用到了，这时要注意用 erase 删除不需要的元素。

`析构函数`
每个类都有析构函数。析构函数控制对象销毁时执行什么操作。
析构函数一般用来释放对象分配的资源。如 vector 的析构函数销毁它的元素并释放内存。

`使用动态内存的三种情况`

1. 不知道需要使用多少对象。例如容器类
2. 不知道对象的准确类型。
3. 需要在多个对象间共享内存。


`使用动态内存在多个对象间共享内存`
定义一个类，类的数据成员为一个 shared_ptr。使用此 shared_ptr 来管理一个 vector，即可实现在多个类对象间共享同一个 vector。当所有类对象都被销毁时 vector 才会被销毁。注意一个类只会与它的拷贝共享一个 vector，单独定义的两个类是不共享的。


`一个实例：StrBlob类`
StrBlob 类是一个使用动态内存在多个对象间共享内存的例子。
StrBlob 类中仅有一个 shared_ptr 成员，这个 shared_ptr 指向一个 string 的 vector。
```c++
#include <vector>
#include <string>
#include <initializer_list>
#include <memory>
#include <exception>

using std::vector; using std::string;

class StrBlob {
public:
    using size_type = vector<string>::size_type;      // 灵活使用类型别名

    StrBlob():data(std::make_shared<vector<string>>()) { }
    StrBlob(std::initializer_list<string> il):data(std::make_shared<vector<string>>(il)) { }  //定义了一个接受初始化列表的转换构造函数（注意不是 explicit 的）

    size_type size() const { return data->size(); }   // size() 函数不改变数据成员，所以声明为 const 的
    bool empty() const { return data->empty(); }      // 声明为 const 的

    void push_back(const string &t) { data->push_back(t); }
    void pop_back() {
        check(0, "pop_back on empty StrBlob");
        data->pop_back();
    }

    std::string& front() {
        check(0, "front on empty StrBlob");
        return data->front();
    }

    std::string& back() {
        check(0, "back on empty StrBlob");
        return data->back();
    }

    const std::string& front() const {       //在普通的 front() 函数外又重载了一个 const 的版本
        check(0, "front on empty StrBlob");
        return data->front();
    }
    const std::string& back() const {       //在普通的 back() 函数外又重载了一个 const 的版本
        check(0, "back on empty StrBlob");
        return data->back();
    }

private:
    void check(size_type i, const string &msg) const {   //定义了一个 check 函数来检查索引是否超出边界
        if (i >= data->size()) throw std::out_of_range(msg);  //不检查 i 是否小于 0 是因为 i 的类型是 size_type，是无符号类型，如果 i<0 会被自动转换为大于 0 的数
    }

private:
    std::shared_ptr<vector<string>> data;
};
```

