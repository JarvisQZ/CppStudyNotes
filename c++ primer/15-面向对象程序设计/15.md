[toc]

# **第15章 面向对象程序设计**

面向对象程序设计的核心思想：数据抽象、继承、动态绑定。

继承和动态绑定的影响：

1. 可以更容易定义与其他类相似但不完全相同的新类。
2. 使用彼此相似的类编写程序时，可以在一定程度上忽略掉他们的差别。

## **15.1 OOP:概述**

**继承**

**基类**位于层次关系的根部，其他类直接或间接地从基类继承而来，继承得到的类称为**派生类**。

基类负责定义所有类共有的成员，派生类定义各自特有的成员。

对于某些成员函数，基类希望它的派生类各自定义适合自身的版本，此时就将这些函数声明为**虚函数**。

派生类通过**类派生列表**来指出它从哪个或哪些基类继承而来。

类派生列表：首先是一个冒号，然后是以逗号分隔的基类列表，每个基类前面可以有访问说明符。

```c++
class Undergraduate : public Student {};
```

派生类**必须在内部对所有重新定义的虚函数进行声明**，声明时可以在前面加上 virtual，也可以不加。

C++11 允许使用 **override** 关键字显式地指明重新定义的虚函数，把 override 放到形参列表后面。

**动态绑定**

当使用**基类的引用或指针**来调用一个**虚函数**时将发生**动态绑定**。

动态绑定根据传入的参数类型来选择函数版本（可能是基类中的该函数或派生类中的该函数），它发生在运行时，又称**运行时绑定**。

## **15.2 定义基类和派生类**

### **15.2.1 定义基类**

**成员函数与继承**

基类通常都应该定义一个**虚析构函数**，即使该函数不执行任何操作也是如此。

基类通过虚函数区分两种成员函数：

1. 基类希望派生类进行覆盖的函数，将其定义为虚函数。构造函数与静态函数都不能定义成虚函数。任何**构造函数之外**的**非静态函数**都可以定义为虚函数。
2. 基类希望派生类直接继承不要改变的函数。

使用指针或引用调用虚函数时，该调用将被动态绑定。

如果基类把一个函数声明为虚函数，该函数在派生类中隐式地也是虚函数。

虚函数的解析过程发生在运行时，普通函数的解析过程发生在编译时。

**访问控制与继承**

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。

派生类能访问基类的公有成员和受保护成员，不能访问私有成员。

### **15.2.2 定义派生类**

派生类通过类派生列表来指出它从哪个或哪些基类继承而来。

**类派生列表：**首先是一个冒号，然后是以逗号分隔的基类列表，每个基类前面可以有访问说明符。

访问说明符包括：public, protected, private。

**派生类中的虚函数**

派生类经常覆盖它继承的虚函数。如果没有覆盖，派生类会直接继承其在基类中的版本。

C++11 允许使用 override 关键字显式地指明重新定义的虚函数，把 override 放到形参列表后面、或 const 成员函数的 const 关键字后面、或引用成员函数的引用限定符后面。

**派生类对象及派生类向基类的类型转换**

一个派生类对象有多个组成部分：一个含有派生类自己定义的成员的子对象，一个与该派生类继承的基类对应的子对象。

因为派生类对象中含有与基类对应的组成部分，所以可以把派生类的对象当成基类对象来使用，也能把基类的指针或引用绑定到派生类对象中的基类部分上。

```c++
Undergraduate gra;
Student *stu = &gra;
```

**派生类构造函数**

派生类不能直接初始化从基类继承来的成员，而是使用基类的构造函数来初始化它的基类部分。

**每个类控制自己的成员初始化过程**。派生类构造函数通过构造函数初始化列表将实参传递给基类构造函数。

```c++
Undergraguate(int age,int sex,string _major)
    : Student(age,sex),major(_major) 
    {}
```

默认情况下，派生类对象的基类部分会像数据成员一样默认初始化。如果要使用其他的基类构造函数，需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。

首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

**注意：每个类负责定义各自的接口**，要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。因此派生类对象不能直接初始化基类的成员。

**继承与静态成员**

基类的静态成员只存在唯一一个实例，不论有多少派生类。

如果静态成员是可访问的，派生类也能使用它

**派生类的声明**

派生类的声明不包含派生列表（定义包含）。

**被用作基类的类**

必须完整定义某个类后，该类才能作为基类被其他类继承。只声明是不够的。

继承可以多重继承，最终的派生类将包含它的直接基类的子对象和每一个间接基类的子对象。

**防止继承的发生**

如果定义了一个类并不希望它被其他类继承，可以在类名后跟一个关键字 **final**

```c++
class Student final {};//类 Student 是不能被继承的
```

### **15.2.3 类型转换与继承**

注意：理解基类和派生类之间的类型转换是理解 C++ 面向对象编程的关键所在。

可以将基类的指针或引用绑定到派生类对象上有一层重要含义：当使用基类的引用或指针时，实际上我们并不清楚它所绑定对象的真实类型，可能是基类对象也可能是派生类对象。

智能指针类也支持派生类向基类的转换。

派生类向基类的类型转换也可能因为访问受限而不可行。

**静态类型与动态类型**

基类的指针或引用的静态类型和动态类型可能不一致。区分静态类型与动态类型：

```c++
Undergraduate gra;
Student* stu = &gra;
```

stu 的静态类型是 Student*，这在编译时就是已知的，但是动态类型到运行时才知道，这里 stu 的静态类型和动态类型是不一致的。

**不存在从基类向派生类的隐式类型转换**

派生类可以向基类转换是因为派生类对象中包含基类部分，而基类的引用或指针可以绑定到该基类部分上，反过来是不行的。

```c++
Student& stu = gra;
Undergraduate gra2 = stu;//错误
```

**在对象之间不存在类型转换**

派生类向基类的转换只对指针或引用类型有效。

当初始化或赋值一个类类型的对象时，实际是调用构造函数或赋值运算符。他们通常包含一个参数：该参数类型是类类型的 const 引用。此时是可以将派生类对象赋值给基类对象的，实际运行的是以引用作为参数的赋值运算符。

```c++
Student{
    Student(const Student& stu) {name = stu.name; age = stu.age;}
    operator=(const Student& stu) {name = stu.name; age = stu.age;}
}
Undergraduate gra;
Student stu1(gra);//正确
Student stu2 = gra;//正确
```

当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，其他部分会被忽略掉。

## **15.3 虚函数**

虚函数**必须提供定义**，即使没有被用到。因为编译器不知道哪个虚函数在运行时会被使用到。

只有当通过指针或引用调用虚函数时才会发生动态绑定，正常调用虚函数时不会发生动态绑定。

**派生类中的虚函数**

当在派生类中覆盖了某个虚函数时，可以用 virtual 指明也可以不用。虚函数在所有的派生类中都是虚函数。

如果派生类的函数覆盖了继承而来的虚函数，它的**形参类型必须与被覆盖的基类函数完全一致。返回类型也必须相匹配。**

**final 和 override 说明符**

如果派生类定义了一个函数与基类中虚函数名字相同但形参列表不同是合法的，不会报错。编译器会认为这个新定义的函数与基类中原有的函数时相互独立的。

C++11 中可以使用 override 来指明派生类中的虚函数。这时如果该函数没有覆盖基类中的虚函数，编译器就会报错。

可以把某个函数指定为 final，这样该函数就不能被派生类所覆盖

**final 和 override 都写到形参列表和尾置返回类型之后。**

**虚函数与默认实参**

虚函数也可以有默认实参，实参值由调用的静态类型决定。即如果通过基类的指针或引用调用虚函数，则使用基类中定义的默认实参。

如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

**回避虚函数的机制**

有时希望对虚函数的调用不进行动态绑定，而是强迫执行虚函数的某个特定版本，可以通过作用域运算符来实现。

```c++
double price = baseP->Quote::net_price(42);//net_price 是虚函数，这里指定调用基类 Quote 的虚函数版本。
```

通常只有在成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的机制。或者当一个派生类的虚函数需要调用它的基类版本时。

## **15.4 抽象基类**

**纯虚函数**

可以将一个没有实际意义的虚函数定义为**纯虚函数**，只需当在类内对它进行声明时最后加一个 =0 即可，无需额外定义。

```c++
Student{
    virtual GetMaior()=0;//这是一个纯虚函数
}
```

**含有纯虚函数的类是抽象基类**

含有纯虚函数的类是**抽象基类**。不能直接创建一个抽象基类的对象。

可以创建派生类的对象，前提是派生类覆盖了原本的纯虚函数，否则该派生类也是抽象基类。



## **15.5 访问控制与继承**

每个类分别制自己的成员初始化进程，也控制着自己的成员对于派生类来说是否可访问。

**受保护的成员**

一个类使用 protected 关键字来声明希望对派生类可见但对其他用户不可见的成员。

派生类的成员和友元可以通过派生类对象访问基类的受保护成员，但是不能直接通过基类对象来访问。

**公有、私有和受保护继承**

一个类对继承的基类成员的访问权限受两方面影响：

1. 基类中该成员的访问说明符
2. 派生类的派生列表中的访问说明符

派生列表中的访问说明符不会影响派生类自身的成员和友元对基类的访问权限，对直接基类的访问权限只与基类中的访问说明符有关。它影响的是派生类的用户（包括派生类的对象、派生类的派生类）对基类成员的访问权限。

```c++
Student{
public:
    void SetAge(int i);    
}

class Undergraduate : private Student {}
Undergraduate gra;
gra.SetAge(20);//错误：对基类Student的继承是私有的，外部不可见
```

如果继承是公有的，则在派生类中，基类的成员将遵循原有的访问说明符

如果继承是受保护的，则基类的所有公有成员在派生类中都是受保护的。

如果继承是私有的，则基类的所有公有和受保护成员在派生类中都是私有的。

**派生类向基类转换的可访问性**

1. 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换。
2. 无论 D 以什么方式继承 B，D 的成员函数和友元都能使用派生类向基类的转换。
3. 如果 D 以受保护的方式继承 B，则 D 的派生类的成员和友元也可以使用 D 向 B 的类型转换。

**类的几种用户**

不考虑继承时，可以认为类有两种用户：

1. 普通用户：普通用户的代码使用类的对象，只能访问类的公有成员。
2. 类的实现者：实现者负责编写类的成员和友元。成员和友元可以访问类的所有部分。

考虑继承时出现了第三种用户

1. 派生类：类的公有成员和受保护成员可以对派生类可见。

**友元与继承**

友元关系不能传递也不能继承。

如果类 A 是基类 B 的友元，那么 A 可以访问 B 对象的成员和 **B 的派生类对象中属于 B 部分的成员**。

**改变个别成员的可访问性**

可以使用 **using 声明**改变派生类继承的某个名字的访问级别。

using 声明位于 public 部分就是公有成员，位于 private 部分就是私有成员，位于 protected 部分就是受保护成员。

如下，Undergraduate 对 Student 的继承是私有继承，所以 Student 的所有成员在默认情况下都是 Undergraduate 的私有成员。

但是通过 using 声明，GetAge 成为了它的公有成员，age 成为了它的受保护成员。

```c++
class Student{
public:
    int GetAge();
protected:
    int age;    
}
class UnderGraduate : private Student{
public:
    using Student::GetAge;//不用加括号
protected:
    using Student::age;    
}
```

**默认的继承保护级别**

和直接定义相似，当继承时不使用访问说明符，使用 class 关键字定义的派生类**默认是私有继承**的，使用 struct 关键字定义的派生类默认是公有继承的。

```c++
class Student{};
class Undergraduate : Student{}; //默认 private 继承
struct Undergraduate : Student{}; //默认 public 继承
```

struct 和 class 两个关键字唯一的区别就是默认成员访问说明符和默认派生访问说明符，没有其他任何区别。

## **15.6 继承中的类作用域**

每个类定义自己的作用域，在这个作用域内定义类的成员。

派生类的作用域嵌套在基类的作用域内。理解这句话：

```c++
Undergraduate gra;
cout << gra.GetAge();
```

这里通过 Undergraduate 的对象来调用 GetAge，所以首先在 Undergraduate 中查找名字 GetAge，没有找到。因为它是 Student 的派生类，所以下一步接着在 Student 中查找，找到并解析。

**在编译时进行名字查找**

一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，即使静态类型和动态类型可能不一致。

如果一个基类的成员在基类中是私有的，在派生类中是公有的。那是不能通过基类对象来访问该成员的，因为这个对象的静态类型是基类，而该成员在基类中是私有的。

**名字冲突与继承**

派生类也能重用定义在其基类中的名字，重用后派生类的成员将隐藏同名的基类成员。

定义在派生类的函数不会重载基类中的同名成员，而是直接隐藏掉。

**除了覆盖虚函数外**，派生类最好不要重用基类成员的名字。

**通过作用域运算符来使用隐藏的基类成员。**

**虚函数与作用域**

派生类在重定义从基类继承的虚函数时，形参列表必须与基类的虚函数相同。

如果不同，派生类定义的将是一个新函数，该新函数不是虚函数，并且会隐藏掉从基类继承的同名虚函数。



## **15.7 构造函数与拷贝控制**

### **15.7.1 虚析构函数**

因为继承关系的影响，**基类通常应该定义一个虚析构函数。**

因为经常通过动态分配来生成类的对象，使用完后要 delete 掉相应的类指针，这时需要调用类的析构函数来销毁对象。但是类指针的静态类型可能是基类的指针，却动态绑定到了一个继承类，这时需要保证 delete 执行的是继承类的析构函数。所以要将析构函数定义为虚析构函数，这样可以通过动态绑定执行正确的版本。

只要基类的析构函数是虚函数，就可以保证 delete 基类指针时运行正确的析构函数版本。

虚析构函数将会阻止编译器合成移动操作。

### **15.7.2 合成拷贝控制与继承**

注意：本节所说的都是编译器合成的拷贝控制成员，而非自定义的。

继承类的合成拷贝控制成员（构造函数、析构函数、赋值运算符等）在对其中的基类部分进行相关拷贝、销毁等操作时都是通过调用基类的对应成员完成的。

**派生类中删除的拷贝控制与基类的关系**

如果基类的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是删除的，那么派生类中对应的成员也会是删除的（因为派生类中的拷贝控制成员需要调用基类的对应成员来完成操作）。

如果基类有一个不可访问或删除的析构函数，则派生类中合成的默认和拷贝构造函数也会是删除的，因为编译器无法销毁派生类对象的基类部分。

如果基类的移动操作是删除的，那么派生类中的对应函数也是删除的，因为派生类的基类部分不可移动。

**移动操作与继承**

因为大多数基类都会定义一个虚析构函数，所以默认情况下基类通常没有合成的移动操作。

如果需要执行移动操作，首先要在基类中定义。之后派生类会自动合成移动操作。

```c++
class Quote{
public:
    Quote() = default;                         //合成的默认构造函数
    Quote(const Quote&) = default;             //合成的拷贝构造函数
    Quote(Quote&&) = default;                  //合成的移动构造函数
    Quote& operator=(const Quote&) = default;  //合成的拷贝赋值运算符
    Quote& operator=(Quote&&) = default;       //合成的移动赋值运算符
    virtual ~Quote() = defalut;                //合成的虚析构函数
}
```

### **15.7.3 派生类的拷贝控制成员**

当派生类定义了拷贝或移动操作（包括对应的构造函数和复制运算符），该操作负责拷贝或移动包括基类部分成员在内的整个对象（通过调用基类的对应成员）。

无论基类的构造函数和赋值运算符是自定义的还是合成的，派生类的对应操作都可以使用它们。

析构函数不同，因为析构部分是隐式销毁的，基类部分也是自动销毁的，不需要派生类来负责。

**在构造函数和析构函数中调用虚函数**

如果在构造函数或析构函数中调用了某个虚函数，则会执行与构造函数或析构函数所属类型相对应的虚函数版本（即不会执行派生类的虚函数版本）。

理解：因为派生类构造函数会先调用基类构造函数完成基类部分的初始化，如果基类的构造函数调用了某个虚函数，而该虚函数的派生类版本访问了派生类的成员（还未进行初始化），会发生错误。

在构造函数和析构函数中调用虚函数是合法的，但非常不建议如此使用。

### **15.7.4 继承的构造函数**

派生类能够重用其直接基类定义的构造函数。这些构造函数并非以常规的方式继承而来。

一个类只初始化它的直接基类，一个类也只继承其直接基类的构造函数（类不能继承默认、拷贝、移动构造函数，这三种构造函数如果没有定义类会自己合成）

派生类通过一个 using 声明语句来继承基类的构造函数

```c++
class Undergraduate : public Student{
public:
    using Student::Student;    
}
```

通常 using 声明语句只是令某个名字在当前作用域内可见。但是当作用域构造函数时，using 声明语句将令编译器产生代码。

对于基类的每个构造函数，编译器都生成一个形参列表完全相同的派生类构造函数。

```c++
derived(parms) : base(args) {} //编译器生成的构造函数的形式
```

如果派生类有自己的数据成员，这些成员将被默认初始化。

理解：继承的构造函数就是相当于派生类采用基类的构造函数初始化自己的基类部分，而派生类中定义的成员采用默认初始化。也可以直接定义具有相同功能的构造函数。

**继承的构造函数的特点**

和普通成员的 using 声明不一样，构造函数的 using 声明不会改变该构造函数的访问级别（即不管 using 声明在哪，派生类的构造函数的访问级别和基类中对应的构造函数的访问级别都是一样的）。

如果基类的构造函数是 explicit 或 constexpr 的，则继承的构造函数也有相同的属性。

当一个基类构造函数含有默认实参，这些实参并不会被直接继承，派生类会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。

如果基类含有几个构造函数，大多数时候派生类会继承所有这些构造函数。除了两个例外情况：

1. 如果基类的某个构造函数和派生类自己定义的构造函数具有相同的参数列表，则该构造函数不会被继承。
2. 默认、拷贝、移动构造函数不会被继承。

## **15.8 容器与继承**

使用容器存放继承体系中的对象时，通常采用间接存储的方式，如存储对象的指针。

**不能把基类和派生类同时放到一个容器中**

```c++
vector<Student> stus; //容器的元素是基类类型
Undergraduate ug;
stus.push_back(ug);  //正确，但是 stus 中只保存了 ug 里的基类部分，已经不是原来的对象了。
```

**在容器中放（智能）指针而非对象**

当要在容器中存放继承体系中的对象时，使用基类指针作为容器的元素类型。