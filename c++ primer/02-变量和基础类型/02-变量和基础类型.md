[toc]
# 2. 变量和基础类型

## 2.1 基本内置类型
基本内置类型包括算数类型和空类型。算数类型包括字符、整型数、浮点数和布尔值。

### 2.1.1 算数类型
| 类型        | 最小尺寸     |
| :---------- | :----------- |
| bool        | 未定义       |
| char        | 8位          |
| w_char_t    | 16位         |
| char16_t    | 16位         |
| char32_t    | 32位         |
| short       | 16位         |
| int         | 16位         |
| long        | 32位         |
| long long   | 64位         |
| float       | 6位有效数字  |
| double      | 10位有效数字 |
| long double | 10位有效数字 |

类型选择：
- 明确知晓数值不可能为负时，选用无符号类型。
- 整数运算用 int，数值太大时用 long long，不用 short 和 long
- 浮点数运算用 double。float 和 double 的计算代价相差无几

### 2.1.2 类型转换

- 把浮点数赋给整型时，结果仅保留小数点前的部分。
- 赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。比如 -1 赋给 8 位 unsigned char 的结果是 255（-1=256*(-1)+255）
- 赋给带符号类型超出范围的值时，结果是未定义的。程序可能工作，可能崩溃。
- 程序尽量避免依赖于实现环境的行为。比如 int 的尺寸在不同环境可能不同。
- 一个表达式中既有无符号数又有int值时，int会被转换成无符号数。
- 无符号减无符号数，结果还是无符号数，如果是负值就等于该符数加上无符号数的模

### 2.1.3 字面量
整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。


## 2.2 变量

c++中，对象通常指一块能存储数据并具有某种类型的内存

### 2.2.1 初始化

```c++
int i = 1;
int i = {0};
int i{0}; // 列表初始化
int i(0);
```
建议初始化每一个内置类型的变量。

## 2.3 复合类型
复合类型就是基于其他类型定义的类型，引用和指针是其中两种。
### 2.3.1 引用
引用是给对象起的别名。

引用必须初始化。引用的初始值必须是一个对象，不能是字面值。

引用非对象。

不能定义对引用的引用，因为引用非对象。

```c++
int &r = i;
```

引用只能绑定在对象上，不能与字面值或表达式绑定。

### 2.3.2 指针
在块作用域内，指针如果没有被初始化，值将不确定。

```c++
int i = 0;
double *dp = &i;   // 错误
long *lp = &i;     // 错误
int *ip = i;       // 这个也是错误的，但 int *ip = 0; 是正确的
```

指针与引用的不同：
- 指针是一个对象而引用不是；
- 指针可以重定向引用不可以；
- 有指向指针的指针无引用的引用；
- 指针不需要在定义时赋初值而引用需要。
- 不能定义指向引用的指针。可以定义指向指针的引用。
```c++
int *p; 
int* &r = p;      // r是对指针p的引用
```

**建议初始化所有指针**

## 2.4 const 限定符
const 对象必须初始化，因为一旦创建就不能再改变值。

默认情况下，const 对象仅在文件内有效。

如果想在多个文件间共享 const 对象，必须在变量的定义前添加
extern 关键字并在本文件中声明。
声明和定义都要加 extern

### 2.4.1 const 的引用
常量引用是对const的引用，对象不必是常量。对const对象的引用也必须是常量。

引用必须初始化，所以常量引用也必须初始化。

```c++
const int ci = 42;
const in &r = ci;
```
不能用非常量引用指向一个常量对象。
可以用常量引用指向一个非常量对象。

### 2.4.2 指针和 const

指向常量的指针的用法和常量引用相似，`但是是不一样的`。它既可以指向常量也可以指向非常量，不能改变对象的值。但是非常量对象可以通过其他途径改变值

### 2.4.3 顶层 const

顶层 const 表示指针本身是个常量，
底层 const 表示指针所指的对象是一个常量。
顶层 const 对任何数据类型通用，底层 const 只用于引用和指针。

星号 * 右边是顶层const
星号 * 左边是底层const

### 2.4.4 constexpr和常量表达式

常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。

字面值属于常量表达式，由常量表达式初始化的 const 对象也是常量表达式。



## 2.5 处理类型
### 2.5.1 类型别名
有两种方法定义类型别名
```c++
typedef double wages;  // 使用 typedef 关键字
using wages = double;  // 使用 using 关键字进行别名声明
```

### 2.5.2 auto 类型说明符
auto 说明符让编译器根据初始值来分析表达式所属的类型。
理解：使用 auto 会增加编译时间，但不会增加运行时间。



## 2.6 自定义数据结构

### 2.6.1 定义Sales_data类型
```c++
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}
```
定义类时可以给数据成员提供类内初始值以进行初始化。
没有类内初始值的成员则被默认初始化。

### 2.6.3 编写自己的头文件
头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr 等。

`预处理器概述`
确保头文件多次包含仍能安全工作的常用技术是预处理器。

预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。

整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。

c++中包含三个头文件保护符：
- #define：把一个名字设定为预处理变量
- ifndef：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到#endif为止
- #endif

预处理变量无视作用域的规则，作用范围是文件内