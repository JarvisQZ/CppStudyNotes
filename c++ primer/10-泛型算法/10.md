[toc]

# 第十章 泛型算法
标准库提供了一组算法，用来处理不同的容器
## 10.1 概述

大多数算法定义在头文件 algorithm 中，部分在numeric中
这些算法不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作。
这些算法不会改变容器的大小

## 10.2 初识泛型算法
标准库提供了超过100个算法

标准库算法都对一个范围内的元素进行操作，此元素范围称为 `输入范围`
部分算法从两个序列中读取元素，两个序列不必相同（如vector 和 list），序列中的元素也不必相同（如double和int），要求是只要能比较两种元素即可。

`几种假定`
操作两个序列的算法有的接受三个迭代器：前两个表示第一个序列的元素范围，第三个表示第二个序列的元素范围，这种情况假定第二个序列至少与第一个序列一样长

向目的位置迭代器写入n个数据的算法假定目的位置足够大 大于等于n

### 10.2.1 只读算法
对于只读算法，最好使用cbegin() cend()
```c++
int sum = accumulate(vec.cbegin(),vec.cend(),val);//对输入范围内的元素在 val 的基础上求和。可以对字符串“+”。注意元素是加在val上，如果元素是double，val是int，和会被转换成int
bool F = equal(vec1.cbegin(),vec1,end(),vec2.cbegin());//比较两个序列的元素是否全部相等（假定第二个序列至少与第一个序列一样长）
auto iter = find_if(vec.begin(),vec.end(),'一元谓词');//查找符合某条件的元素，返回迭代器，如果没有就返回尾迭代器
```

### 10.2.2 写容器元素的算法

```c++
fill(vec.begin(),vec.end(),val);//将 val 赋予输入序列中的每一个元素
fill(vec.begin(),vec.begin() + vec.size()/2,10);//将一个容器的前一半的值写为10

fill_n(dest,n,val);//将 val 赋予从 dest 开始的连续 n 个元素。假定dest开始的序列有至少 n 个元素
fill_n(vec.begin(),vec.size(),0);//将 vec 的所有元素重置为0

for_each(vec.begin(),vec.end(),'可调用对象');
//对输入范围内的每一个元素执行可调用对象的内容。注意：可调用对象是一元谓词，参数类型是迭代器指向的类型
```

插入迭代器
插入迭代器是一种向容器内部添加元素的迭代器
当通过插入迭代器赋值时，一个新的元素被添加到容器中
```c++
vector<int> vec;
auto it = back_inserter(vec);//it 即为vec新加的插入迭代器
*it = 24;//给 it 赋值后，vec 现在有一个元素为 24
```

拷贝算法
```c++
auto ret = copy(begin(a1),end(a1),begin(a2));//把数组 a1 的内容拷贝给 a2，返回的是目的位置迭代器（递增后）的值

replace(ilst.begin(),ilst.end(),0,42);//把输入范围内所有值为 0 的元素改为 42
replace_copy(ilst.begin(),ilst.end(),dest,0,42);//把输入范围内所有值为 0 的元素改为 42 并拷给 dest 开头的序列。
```

### 10.2.3 重排容器元素的算法
```c++
sort(words.begin(),words.end());//默认按字典序从小到达排列输入范围内的元素。重复的元素会相邻
auto end_unique = unique(words.begin(),words.end());
//将输入范围内的元素重排，将重复的元素里不是第一次出现的元素都放到序列的后端。返回指向序列后端重复元素中的第一个重复元素的迭代器。
words.erase(end_unique,words.end());//删除重复的元素。erase()函数可以接受两个相等的迭代器作为参数。
```

## 10.3 定制操作
可以使用自定义操作符来替代默认运算符。

### 10.3.1 向算法传递函数
谓词是一个可调用的表达式，返回结果是一个可以作为条件的值，如返回一个 bool 值。
谓词的参数类型必须是元素类型可以转换到的类型。谓词的实参是输入序列的元素（是元素本身不是迭代器）
谓词分为一元谓词和二元谓词，分别接受一个参数和两个参数。不同的标准库算法会接受不同的谓词作为参数。

### 10.3.2 lambda表达式

ambda 表达式适合那种只在一两个地方使用的简单操作。
可以向一个算法传递任何类别的可调用对象。
总共有四种可调用对象：函数、函数指针、重载了函数调用运算符的类、lambda表达式
lambda表达式组成部分：捕获列表、参数列表、返回类型、函数体
```c++
[capture list](parameter list)->return type {function body}
捕获列表的内容为 lambda所在函数中定义的局部变量（直接写局部变量的名字即可，通常为空）。捕获列表只用于局部非 static 变量。
```
捕获列表的内容为 lambda所在函数中定义的局部变量（直接写局部变量的名字即可，通常为空）。捕获列表只用于局部非 static 变量。
参数列表和返回类型都可以省略。如果忽略返回类型，则根据 return 语句推断返回类型（此时函数体必须只有 return 语句）。
```c++
auto f = []{ return 42};//定义了一个可调用对象 f，返回 42
lambda表达式的调用方式也是使用调用运算符，内含实参。
```
lambda表达式的调用方式也是使用调用运算符，内含实参。
lambda 没有默认参数。

### 10.3.3  lambda捕获和返回

定义一个 lambda 时，编译器生成一个与 lambda 对应的未命名的类类型。
当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象：传递的参数实际上就是此编译器生成的类类型的未命名对象。
类似，auto f = [ ]{ return 42; } 实际上定义了一个类类型的对象。
默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员。
lambda 捕获变量的方式分为值捕获和引用捕获，类似参数传递。

`值捕获`
注意采用值捕获的前提是变量可以拷贝。（iostream 等类型不可拷贝）
被值捕获的变量的值是在 lambda 创建时拷贝，而非调用时拷贝。因此在 lambda 创建后改变被捕获的变量不会影响 lambda 中对应的值。

`引用捕获`
采用引用捕获时，在捕获列表中的变量名前加上引用符即可。
注意采用引用捕获必须确保被引用的对象在 lambda 执行时是存在的。
lambda 捕获的都是上层函数的局部变量，在函数结束后就都不复存在了。
引用捕获可以用于捕获变量是 IO 类型时。

`使用 lambda`
lambda 和含有可调用对象的类对象都可以作为函数的返回值，要注意此时 lambda 不能包含引用捕获。
应该尽量减少捕获的数据量，同时尽量避免捕获指针或引用。
捕获列表中可以同时有值捕获的变量和引用捕获的变量

`隐式捕获`
一般在捕获列表中显式地列出所有的捕获变量，但也可以采用隐式捕获。隐式捕获情况下，编译器会根据 lambda 中的代码来推断要使用的变量。
隐式捕获只需在捕获列表中写一个 & 或 = 即可，& 表示采用引用捕获，= 表示采用值捕获。
```c++
wc = find_if(words.begin(), words.end(), [=](const string& s){ return s.size()>=sz; });
```

`混合显式捕获与隐式捕获`
可以通过混合使用隐式捕获和显示捕获来实现对一部分变量使用值传递，而另一部分使用引用传递。
混合捕获时捕获列表中的第一个元素必须是一个 & 或 =：
如果是 &，表示采用隐式的引用捕获，此时后面显式捕获的变量必须都采用值捕获。
如果是 =，表示采用隐式的值捕获，此时后面显式捕获的变量必须都采用引用捕获。
```c++

for_each(words.begin(), words.end(), [&,c](const string& s){ os<<s<<c; });   // 这里的 os 是通过隐式的引用捕获得到的。
for_each(words.begin(), words.end(), [=, &os](cosnt string& s){ os<<s<<c;}); // 这里的 c 是通过隐式的值捕获得到的。
```

`捕获列表`
总结可得，捕获列表可以有六种形式
```c++
[],[参数序列]             // 空列表与显式捕获
[=],[&]                  // 隐式值捕获与隐式引用捕获
[=,参数列表],[&,参数列表] // 混合捕获
```

`可变 lambda`
默认情况下，通过值捕获拷贝的变量，lambda 不会改变其值。如果希望改变，必须在参数列表后加上关键字 mutable。
引用捕获的变量是否可以修改依赖于引用指向的是 const 还是非 const 类型。
指定 lambda 返回类型
如果 lambda 中只包含一个单一的 return 语句，可以省略返回类型。
如果 lambda 中除了 return 还有其他语句，此时应该指明返回类型。

### 10.3.4 参数绑定
lambda 表达式适合那种只在一两个地方使用的简单操作。如果操作需要很多语句或要在很多地方使用，通常应该定义一个函数。
对于捕获列表为空的 lambda，通常可以用函数来代替。对于捕获列表不为空的 lambda，不容易使用函数替换。

`标准库 bind 函数`
bind 函数接受一个可调用对象，生成一个新的调用对象来“适应”原对象的参数列表。bind 函数定义在头文件 functional 中。

`bind 使用示例`
要将 comp2 绑定到 comp1。
comp1 比较两个 int 的大小，comp2 相当于第二个参数的默认实参为 6 的 comp1。
```c++
comp1(5, 6);//比较 5 和 6 的大小
auto comp2 = bind(comp1, _1, 6);//bind 中第一个参数是 comp1 的函数名，后面的参数是 comp1 的参数列表。bind 的返回值是新生成的可调用对象
        //_1 表示 comp2 的第一个参数，这里表示将 comp2 的第一个参数和 comp1 的第一个参数绑定在了一起。
comp2(7);//使用 comp2 比较 7 和 6 的大小。在调用 comp2(7) 时会将其映射为 comp1(7,6);
```


## 10.4 再探迭代器

除了每个容器各自的迭代器外，标准库在头文件 iterator 中定义了四种迭代器：
1. 插入迭代器：绑定到容器上，可以来向容器插入元素。
2. 流迭代器：绑定到输入或输出流上，可以用来遍历所关联的 IO 流。
3. 反向迭代器：这些迭代器向后移动，除了 forward_list 外的标准库容器都有反向迭代器。
4. 移动迭代器：移动迭代器不拷贝其中的元素，而是移动他们。


### 10.4.1 插入迭代器
插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。
`插入器实际上是一个函数。`
注意 back_inserter 是插入器，back_insert_iterator<vector<int>> 是插入迭代器类型。back_inserter(v) 返回绑定到容器 v 的 back_insert_iterator，并实现其自增。
`插入器的三种类型`
1. back_inserter：创建一个使用 push_back 的迭代器。只有容器支持 push_back 才能使 back_inserter
2. front_inserter：创建一个使用 push_front 的迭代器。只有容器支持 push_front 才能使用 front_inserter。
3. inserter：创建一个使用 insert 的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器，元素将被插入到给定迭代器所表示的元素之前。
   
插入迭代器的定义
有两种方式，一种是直接定义，另一种是通过插入器生成
```c++

vector<int> v;
'使用插入器生成'
auto bIn = back_inserter(v);  // bIn 是一个绑定到 v 的插入迭代器。
'直接定义'
back_insert_iterator<vector<int>> bIn(v);        // bIn 是一个绑定到 v 的插入迭代器。
insert_iterator<vector<int>> iIn(v, v.begin());  // iIn 是一个绑定到 v 的插入迭代器
```
`插入迭代器的操作`
有实际意义的插入迭代器操作只有一种，就是赋值操作。
当通过插入迭代器赋值时，插入迭代器调用容器操作来向给定容器的指定位置插入一个元素。

`插入器 inserter 与函数 insert 的不同`
下面的 1 和 2 的效果是一样的。
插入迭代器是恒定指向同一个元素的。而 insert 返回的是指向所插入元素的迭代器
```c++
'1'
auto iIn = inserter(v, v.begin());
*iIn = 10;
'2'
iter = v.insert(v.begin(), 10);
++iter;

// 插入迭代器的使用
vector<int> v1,v2;
*back_inserter(v1) = 1;    // 在 v1 的尾元素之后插入一个 1
*inserter(v1, v1.begin()) = 3; // 在 v1 的首元素之前插入一个 3
copy(v1.begin(),v1.end(),back_inserter(v2)); // 将 v1 的所有元素按顺序拷贝到 v2 的尾元素之后。
copy(v1.begin(),v1.end(),inserter(v2,v2.begin())); // 将 v1 的所有
```

### 10.4.2 iostream迭代器

### 10.4.3 反向迭代器

## 10.5 泛型算法结构
### 10.5.1 5类迭代器
算法所要求的迭代器操作可以分为 5 类，每个算法都会为它的迭代器参数指明需提供哪类迭代器
1. 输入迭代器：只读，不写；单遍扫描，只能递增。
2. 输出迭代器：只写，不读；单遍扫描，只能递增。
3. 前向迭代器：可读写；多遍扫描，只能递增。
4. 双向迭代器：可读写；多遍扫描，可递增递减。
5. 随机访问迭代器：可读写，多遍扫描，支持全部迭代器运算。

迭代器根据支持的操作的多少分层。C++ 标准指明了泛型算法的每个迭代器参数的最小类别。
`输入迭代器`
输入迭代器只用于顺序访问，只能用于单遍扫描算法，如算法 find 和 accumulate。
Istream_iterator 是一种输入迭代器。
`输出迭代器`
只能向一个输出迭代器赋值一次，只能用于顺序访问的单遍扫描算法。如 copy 函数的第三个参数。
ostream_iterator 是一种输出迭代器。
`前向迭代器`
可以读写元素。只能在序列中沿一个方向移动，可以多次读写同一个元素。
可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列多遍扫描。
算法 replace 要求前向迭代器，forward_list 的迭代器是前向迭代器。
`双向迭代器`
可以正向/反向读写序列中的元素。支持递增递减运算符。
算法 reverse 要求双向迭代器。list 的迭代器是双向迭代器。
`随机访问迭代器`
提供在常量时间内访问序列中任意元素的能力。
支持以下操作：
- 支持 <, <=, >, >= 等关系运算符。
- 支持迭代器与整数的加减。
- 支持两个迭代器之间的相减。
- 支持下标运算符。iter[n] 和 *(iter[n]) 含义相同。
  
算法 sort 要求随机访问迭代器。array, deque, vector, string 的迭代器是随机访问迭代器。

### 10.5.2 算法形参模式
算法的形参一般是以下 4 种模式之一
1. alg(beg, end, other args); 
2. alg(beg, end, dest, other args); dest 经常是一个插入迭代器或一个 ostream_iterator，他们都能确保不管写多少元素都肯定是安全的。
3. alg(beg, end, beg2, other args);
4. alg(beg, end, beg2, end2, other args);

### 10.5.3 算法命名规范

```c++
// 算法遵循一同命名和重载规范。
// 重载谓词的算法
// 一些算法使用重载形式传递一个谓词，来代替 < 或 ==。
unique(beg, end);          // 使用 == 比较元素
unique(beg, end, comp);    // 使用 comp 比较元素


// _if 版本的算法
// 接受一个元素值的算法通常有另一个不同名的 _if 版本。
find(beg, end, val);       // 查找范围内 val 第一次出现的版本。
find_if(beg, end, pred);   // 查找第一个令 pred 为真的元素。

// 拷贝版本的算法
// 默认情况下，重排元素的算法会将重排后的元素写回给定的输入序列中。拷贝版本则将元素写到一个给定的位置。
reverse(beg, end);             // 反转序列中的元素。
reverse_copy(beg, end, dest);  // 将元素按逆序拷贝到 dest。

remove_if(v1.begin(), v1.end(), [](int i){return i%2;});                         // 从 v1 中删除奇数元素。
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i){return i%2;}); // 将去掉了奇数元素的 v1 序列拷到 v2 中。
```

## 10.6 特定容器算法
链表类型 list 和 forward_list 定义了几个成员函数形式的算法。它们定义了独有的 sort, merge, remove, reverse 和 unique。

通用版本的 sort 要求随机访问迭代器，而 list 和 forward_list 分别提供双向迭代器和前向迭代器，因此不能用于 list 和 forward_list。

其他链表类型定义的算法的通用版本可以用于链表，但是性能差很多，应该优先使用成员函数版本的算法。

`成员函数版本的算法`
```c++
lst.merge(lst2);        // 将 lst2 的元素合并入 lst。两者必须都是有序的，合并后 lst2 将变为空。使用 < 比较元素。
lst.merge(lst2,comp);   // 上面的 merge 的重载版本，用给定的 comp 代替 <

lst.remove(val);        // 调用 erase 删除掉与给定值相等的每个元素。
lst.remove_if(pred);    // pred 是个一元谓词，删除掉 lst 中使 pred 为真的每个元素。

lst.reverse();          // 反转 lst 中元素的顺序。

lst.sort();             // 使用 < 给元素排序
lst.sord(comp);         // 重载版本

lst.unique();          // 调用 erase 删除同一个值的连续拷贝。
lst.unique(pred);      // pred 是个二元谓词，删除使 pred 为真的连续拷贝。

```


`splice算法`

链表类型定义了 splice 算法，此算法是链表特有的，没有通用版本。
splice 算法用来在两个链表间移动元素或在一个链表中移动元素的位置。

```c++
lst.splice(p, lst2); flst.splice_after(p, lst2);              // p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。
        // 函数将 lst2 中的所有元素移动到 lst 中 p 之前的位置或 flst  中 p 之后的位置。
lst.splice(p, lst2, p2); flst.splice_after(p, lst2, p2);      // p2 是一个指向 lst2 中位置的迭代器。
        // 函数将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中,lst2 可以是与 lst 或 flst 相同的链表。
lst.splice(p, lst2, b, e); flst.splice_after (p, lst2, b, e); // b 和 e 表示 lst2 中的合法范围。
        // 将给定范围中的元素从 lst2 移动到 lst 中。lst2 可以是与 lst 或 flst 相同的链表，但是 p 不能指向 b 和 e 之间的元素。   

```