[toc]

# **第14章 操作重载与类型转换**

## **14.1 基本概念**

重载的运算符是有特殊名字的函数：名字由关键字 operator 和要定义的运算符号组成。

重载的运算符作为函数，也包含返回类型、参数列表和函数体。

重载运算符的参数数量和该运算符作用的运算对象数量一样多。

重载的运算符必须是某个类的成员或至少拥有一个类类型的运算对象。

除了**重载的函数调用运算符 operator()** 之外，其他重载运算符**不能含有默认实参**。

如果运算符函数是类的成员函数，它第一个(左侧)运算对象绑定到隐式的 this 指针上，因此定义成员运算符函数时的参数数量比运算符的运算对象**少一个**。

**调用重载运算符的两种方式：**

1. **直接使用运算符**。如 data1+data2；data1+=data2。+ 是非成员函数，+= 是类的成员函数，两种都可以直接使用。
2. **向调用普通函数一样调用运算符函数**。如 operator+(data1,data2)；data1.operator+=(data2)。

注意运算符函数的函数名是 operator 加运算符本身。

**重载运算符的几个规则：**

1. 通常，不应该重载逗号，取地址，逻辑与和逻辑或运算符。
2. 重载的运算符应该使用和内置类型一样的含义。
3. 如果定义了 ==，一般也应该定义 !=。
4. 如果定义了 <，也应该有其他关系操作。
5. 如果定义了算术运算符或位运算符，也应该有对应的复合赋值运算符，如有 +，也应该有 +=。
6. 重载运算符的返回类型应该与内置类型的返回类型兼容。如逻辑和关系运算符返回 bool，**赋值和复合赋值运算符返回左侧运算对象的一个引用**。
7. 当运算符定义为成员函数，它的左侧运算对象必须是所属类的一个对象。

**运算符应该是成员还是非成员：**

1. 赋值、下标([ ])、调用（( )）、成员访问箭头（->）运算符都必须是成员。
2. 复合赋值运算符一般应该是成员，但非必须。
3. 递增、递减和解引用等运算符应该是成员。
4. **IO 运算符**应该是非成员，**但是应该声明为类的友元**。
5. **具有对称性的运算符**可能转换任意一端的运算对象，如算术、相等性、关系和位运算符等，应该是非成员。

## **14.2 输入和输出运算符**

### **14.2.1 重载输出运算符<<**

通常输出运算符的第一个形参是一个非常量 ostream 对象的引用（因为 IO 类型不能拷贝，所以必须是引用，因为要通过向流写入来输出，这会改变流的状态，所以必须是非常量），第二个形参一般是常量引用（为了避免复制实参，所以应为引用）。**重载的 << 应该返回它的 ostream 形参**。

**定义方式**

```c++
ostream& operator<<(ostream& os, const Student& stu){}
```

重载输出运算符应该尽量减少格式化操作，只负责打印什么内容，而不控制格式。（不应该打印换行符）。

IO 运算符应该是非成员，但是应该声明为类的友元。

### **14.2.2 重载输入运算符>>**

通常输入运算符的第一个形参是一个非常量 istream 对象的引用，第二个形参是要读入的非常量对象的引用。**返回 istream 对象的引用**。

**定义方式**

          ```c++
          istream& operator>>(istream& is,Student& stu){}
          ```

**输入运算符需要检查是否输入成功**

**输入运算符必须检查是否输入成功，并处理输入失败的情况**，而输出运算符不需要。

如果读取失败，输入运算符应该负责从错误中恢复，主要是将输入对象重置为合法状态，一般为未输入前的状态。

**输入时的错误**

1. 当流中含有错误的数据时可能会读取失败
2. 当读取操作到达文件末尾时会失败
3. 遇到输入流的其他错误时也会失败

## **14.3 算术和关系运算符**

算术和关系运算符通常定义为**非成员函数**以允许对左侧或右侧的运算对象进行转换。

算术和关系运算符的形参都应该是常量引用。

### **14.3.0 算术运算符**

一般定义了算术运算符，也应该定义一个对应的复合赋值运算符。一般都是先定义复合赋值运算符，而后**使用复合赋值来实现算术运算符**（**复合赋值运算符一般为成员，而算术为非成员**）。

**实现方式**

一般将算术运算得到的值存放在局部变量中，操作完后返回该变量的副本。

### 14.3.1 **相等运算符**

相等运算符用来比较两个对象是否相等。

**使用规则**

1. 通常会比较对象的每一个数据成员，所有对应成员都相等时两个对象才相等。
2. 定义了 ==，也应该定义 !=。一般通过 == 来实现 !=。
3. 通常相等运算符应该具有**传递性**。

### 14.3.2 **关系运算符**

定义了 == 的类，经常也会包含关系运算符，尤其是 <，因为关联容器和一些算法都要用到 <。

对于有些类来说，有 == 和 !=，但是很难有相应的 <。

**使用规则**

1. 关系运算符一般应该定义顺序关系，令其与关联容器中对关键字的要求一致。
2. 如果同时定义了 == 和 !=，则关系运算符应该与其保持一致，比如如果两个对象是 != 的，那么一个对象应该 < 另一个。

## **14.4 赋值运算符**

赋值运算符必须定义为类的成员函数。

赋值运算符应该返回左侧运算对象的引用。

类中一般已经定义了拷贝赋值和移动赋值运算符。如果需要时也可以继续重载赋值运算符以**使用别的类型作为右侧运算对象**。

```c++
vector<string> v = {"a","an","the"};
```

如上 vector 可以用花括号元素列表做参数。

赋值运算符必须先释放当前的内存空间，再重新分配。

**复合赋值运算符**

复合赋值运算符不必须是成员，但是一般也应该是成员。其左侧运算对象绑定到隐式的 this 指针。

复合赋值运算符也返回左侧运算对象的引用。

## **14.5 下标运算符**

表示容器的类可以通过元素在容器中的位置来访问元素，这些类一般会定义下标运算符 operator[ ]。

下标运算符必须是成员函数。

下标运算符通常以所访问元素的引用作为返回值，这样下标可以出现在赋值运算符的任意一端。

下标运算符最好**同时定义两个版本：**

1. 非常量版本：返回普通引用。
2. 常量版本：是类的常量成员并返回常量引用。常量版本取得的元素不能放在赋值运算符的左侧。

## **14.6 递增和递减运算符**

递增和递减运算符通常定义为成员，但不必须。

递增和递减运算符应该同时定义前置和后置版本。且前置版本返回递增或递减后的引用，后置版本返回修改前的副本。

如果是**用于迭代器的递增递减运算符**，应该检查递增递减是否合法，如 0 不能递减。

**区分前置和后置**

为了区分，可以使后置版本接受一个额外的不被使用的 int 类型的形参，当使用后置版本时，编译器为这个形参提供一个值为 0 的实参。

这个形参的唯一作用就是区分前置和后置。因为不会用到，所以该形参无需命名。

后置版本可以通过调用前置版本来实现。

```c++
Student& operator++();//前置版本
Student& operator++(int);//后置版本 
```

## **14.7 成员访问运算符**

箭头运算符必须是类的成员，箭头运算符一般通过调用解引用运算符来实现。

解引用运算符通常也是类的成员，但不必须。

## **14.8 函数调用运算符**

如果类重载了函数调用运算符，就可以**像使用函数一样使用该类的对象** (被称为函数对象)。

函数调用运算符必须是成员函数，一个类可以定义多个版本的调用运算符。不同版本的参数应有所区别。

理解：当重载了函数调用运算符，类对象的名字就相当于函数名。

             ```c++
             class AbsInt{
                 int operator()(int val) const{  //该函数调用运算符返回一个整数的绝对值
                     return val<0 ? -val : val;
                 }
             };
             '应用'
             AbsInt absObj;          //定义了一个对象
             int ui = absObj(-10);   //使用重载的函数调用运算符
             ```

​        

**含有状态的函数对象类**

函数对象类通常会有一些数据成员，这些数据成员帮助实现函数。

函数对象常作为泛型算法的实参。

```c++
class PrintString{
public:
    PrintString(ostream &_os = cout, char _sep = ' ') : os(_os), sep(_sep) {} 
    void operator()(const string &s) const { os<<s<<sep; }   
};
'应用'
PrintString printString; //采用默认实参，输出到 cout 中，以空格为间隔符
printString(ss);  //打印 string 类对象 ss。
```

​        

### **14.8.1 lambda是函数对象**

编译器会将 lambda 翻译成一个未命名类的未命名对象，在 lambda 表达式产生的类中含有一个重载的函数调用运算符。

默认情况下 lambda 不能修改它的捕获变量(上层函数的局部非 static 变量)，lambda 产生的类中的函数调用运算符是一个 const 成员函数。

当 lambda 被声明为可变的时，调用运算符就不是 const 的了。

```c++
'lambda表达式'
[](const string &a,const string &b){ return a.size() < b.size();}
'上面的lambda表达式类似这个类的未命名对象'
class ShorterString{
public:
    bool operator()(const string &s1, const string &s2) const { return s1.size() < s2.size(); }    
}
```



**lambda 的不同捕获行为**

当 lambda 通过引用捕获变量时，由程序确保 lambda 执行时所引用的对象确实存在。

当 lambda 通过值捕获变量时，捕获的变量被拷贝到 lambda 中，此时**产生的类中会建立对应的数据成员并创建构造函数来初始化数据成员**。

### **14.8.2 标准库定义的函数对象**

标准库定义了一组表示算数运算符、关系运算符和逻辑运算符的**模板类**，每个类分别定义了一个执行命名操作的调用运算符。

例如 plus 可以用来执行 int 类型运算对像的加法

    ```c++
    plus<int> intAdd; //实例化了一个可执行 int 加法的函数对象
    int sum = intAdd(10, 20); //调用 intAdd 来执行 int 加法
    ```



**标准库函数对象**

```c++
'算术'                     '关系'                  '逻辑'
plus<Type>                equal_to<Type>          logical_and<Type>
minus<Type>               not_equal_to<Type>      logical_or<Type>
multiplies<Type>          greater<Type>           logical_and<Type>
divides<Type>             greater_equal<Type>
modulus<Type> '求余'      less<Type>
negate<Type> '相反数'     less_equal<Type> 
```

​          

**在算法中使用标准库函数对象**

表示运算符的函数对象类常用来替换算法中的默认运算符。

```c++
sort(svec.begin(), vec.end(), greater<string>());//使用 greater 对 svec 进行降序排列
标准库规定的函数对象对于指针也是适用的，比如可以使用 less<Type*> 来比较两个指针的大小（比较的是指针变量中的地址大小）
```



标准库规定的函数对象对于指针也是适用的，比如可以使用 less 来比较两个指针的大小（比较的是指针变量中的地址大小）

因为关联容器使用 less 来对元素排序，如果将指针作为 set 或 map 的关键字，元素将自动按地址进行排序。

**注意函数对象其实是一个函数对象类。**

###  **14.8.3 可调用对象与function**

C++ 中的几种可调用的对象：**函数、函数指针、lambda表达式、bind创建的对象、重载了调用运算符的类。**

理解：可调用的对象和其他对象一样，也有自己的类型。如函数的类型是由返回值类型和实参类型决定的。

**不同类型可能具有相同的调用形式**

**调用形式**指明了调用返回的类型和传递给调用的实参类型。

```c++
int(int, int) //这是一个函数类型，它接受两个 int，返回一个 int
下面这三个可调用对象具有相同的调用形式 int(int,int)，但是他们三个不是同一类型
```



下面这三个可调用对象具有相同的调用形式 int(int,int)，但是他们三个不是同一类型

```c++
int add(int i, int j) { return i + j; }       //普通函数
auto mod = [](int i, int j) { return i % j }; //lambda 产生一个未命名的函数对象类，mod 是这个类的一个实例
struct divide{                                //一个函数对象类
    int operator()(int i, int j) { return i / j; }
};
```

​         

**标准库 function 类型**

function 定义在 **functional** 头文件中。function 是一个模板，创建具体的 function 类型时要指明具体的调用形式。

**funcion 操作**

```c++
function<retType(args)> f;//定义了一个用来存储可调用对象的空 function，调用对象的调用形式应该和 retType(args) 相同
function<retType(args)> f(nullptr);//显式地构造一个空 function
function<retType(args)> f(obj);//在 f 中存储可调用对象 obj 的副本
f   //可以将 f 作为条件，如果 f 为空则为假，不为空则为真
f(args)  //通过 f 调用 f 中的对象 
```

​          

**funciton 中定义的类型**

```c++
result_type      //该 funciton 类型的可调用对象返回的类型 retType
argument_type    //retType(args) 中的参数类型
first_argument_type  //retType(args) 中第一个参数的类型
second_argument_type //retType(args) 中第二个参数的类型
```

​         

**使用 function**

```c++
function<int(int, int)> f1 = add;   //add 是个函数指针
funciton<int(int, int)> f2 = divide();  //divide() 返回一个函数对象的对象。
function<int(int, int)> f3 = mod;   //mod 是个命名了的 lambda 对象
```

 

不能直接将重载函数的名字存入 function 类型的对象中，但是可以存储指向确定重载版本的函数指针。

**使用 map 定义一个函数表**

```c++
map<string, int(*)(int, int)> binops;//这种方式只能存储函数和函数指针，不能存储函数对象类和 lambda 表达式
binops.insert("+",add);//正确

map<string, function<int(int, int)>> binops = {  //可以存储相同调用形式的各种可调用对象
    {"-", std::minus<int>()},  //标准库函数对象
    {"/", divide()},           //用户定义的函数对象
    {"%", mod}                 //命名了的 lambda 对象
}
```

​        

## **14.9 重载、类型转换与运算符**

**转换构造函数**和**类型转换运算符**共同定义了类类型转换，这是用户定义的类型转换。

构造函数会实现**从其他类型向类类型的转换**，类型转换运算符实现**从类类型向其他类型的转换**。

只接受一个单独实参的非显式（即非 explicit 的）构造函数定义了从实参类型向类类型的类型转换。

### **14.9.1 类型转换运算符**

类型转换运算符是类的一种特殊成员函数，用来将一个类类型的值转换成其他类型。可以转换成除了 void 外任意可以作为函数返回值的类型，包括引用、指针。

类型转换函数的一般形式：**operator type() const;**

类型转换函数必须是类的成员函数，**不能声明返回类型，形参列表也必须为空，且函数一般是 const 的**。虽然不指定返回类型，但是函数会返回一个对应类型的值。

理解：函数名实际上就是返回类型

```c++
class SmallInt {
public:
    SmallInt(int i=0): val(i) {}
    operator int() const { return val}; //类型转换函数
private:    
    int val;    
}
```

​         

**类型转换函数的使用**

类型转换运算符不需要显式调用，在执行运算时会隐式的执行。

```c++
SmallInt si;
si = 4; //将 4 隐式地转换为 SmallInt，然后调用 SmallInt::operator
si + 3; //将 si 隐式地转换为 int，然后执行整数的加法
```



如果类类型和转换类型间没有明显的映射关系，不要用类型转换运算符。但是向 bool 的类型转换比较常见。

**显式的类型转换运算符**

使用显式的类型转换运算符来避免在不合适的场合发生转换。

用关键字 explicit 来将运算符指定为显式的，调用时需使用 static_cast 来显式转换。

**例外：如果表达式被用作条件，则显式的类型转换会被隐式地执行。**如用在 if 语句的条件部分。

向 bool 类型的转换一般都用于条件部分，因此 **operator bool() 一般定义成 explicit 的**。

         ```c++
         class SmallInt {
         public:
             explicit operator int() const { return val; }
             // 类的其他部分省略。    
         }
         
         SmallInt si = 4;            //正确：构造函数不是显式的
         si + 3;                     //错误：类的运算符是显式的
         static_cast<int>(si) + 3;   //正确：显式地请求类型转换
         ```

### **14.9.2 避免有二义性的类型转换**

要确保在类类型和目标类型之间只存在唯一的转换方式。

有两种情况可能产生多重转换路径：

1. 两个类提供相同的类型转换。A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符。
2. 定义了多个转换规则。

设计重载运算符和类型转换函数时要加倍小心，避免产生二义性。建议：

1. 不要令两个类执行相同的类型转换
2. 避免转换目标是内置算数类型的类型转换。特别是已经定义了一个转换成算数类型的类型转换时。

当有重载函数时，定义类型转换运算符尤其容易发生错误。

**14.9.3 函数匹配与重载运算符**

重载的运算符也是重载的函数，因此也使用函数匹配规则。

使用重载运算符作用域类类型的运算对象时，候选函数集中包含该运算符的普通非成员版本和类的成员函数版本。