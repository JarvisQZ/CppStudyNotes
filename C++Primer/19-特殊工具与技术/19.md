[toc]

# **第19章 特殊工具与技术**

## **19.1 控制内存分配**

### **19.1.1 重载new和delete**

### **19.1.2 定位new表达式**

## **19.2 运行时类型识别**

### **19.2.1 dynamic_cast运算符**

### **19.2.2 typeid运算符**

### **19.2.3 使用RTTI**

### **19.2.4 type_info类**

## **19.3 枚举类型**

和类一样，枚举类型定义了**一种新的类型**。枚举属于**字面值常量类型**。

**C++的****两种枚举类型：**

1. 限定作用域的枚举类型(C++11新标准)
2. 不限定作用域的枚举类型

**限定作用域的枚举类型**

枚举成员的名字遵循常规的作用域准则，且在枚举类型的作用域外是不可访问的。在枚举类型的作用域内最好不要出现同名，但是即使出现了也没错。

```c++
'定义方式'
enum class Color1 {green, blue};  // class 可以等价地换位 struct
'使用'
Color1 eyeColor = Color1::blue;   // 使用作用域运算符访问枚举成员
```

限定作用域的枚举类型的对象不能被当成整型值来使用

```c++
int a = Color1::blue;  // 错误
```

**不限定作用域的枚举类型**

枚举成员的作用域与枚举类型本身的作用域相同。因此在作用域内，不能出现与枚举成员相同的名字

```c++
'定义方式'
enum Color2 {red, yellow};
'使用'
Color2 hairColor1 = red;          // 可以不使用作用域运算符访问枚举成员
Color2 hairColor2 = Color2::red;  // 也可以使用作用域运算符访问枚举成员
```

不限定作用域的枚举类型的对象可以自动转换成整型

```c++
int b = red;  // 正确
```

**枚举成员的值**

默认情况下，枚举值从 0 开始，依次加 1。也可以在定义枚举类型时为一个或多个枚举成员指定专门的值。

如果没有显式地提供初始值，则当前枚举成员的值等于上一个枚举成员的值加 1。

**枚举成员是常量表达式（const）**，因此也必须用常量表达式初始化枚举成员。

switch 语句中 case 标签的值必须是常量表达式，可以用枚举成员做 case 标签。

**和类一样，枚举也定义新的类型**

初始化 enum 对象或为 enum 对象赋值，必须使用枚举成员或另一个同类型的 enum 对象，**不能使用整型值**。

```c++
Color1 eyeColor1 = Color1::green; // 使用枚举成员初始化
Color1 eyeColor2 = eyeColor1;     // 使用同类型的 enum 对象初始化
Color1 eyeColor3 = 0;             // 错误：不能只用整型值
```

**enum 成员的类型**

限定作用域的 enum 成员类型默认是 int，不限定作用域的 enum 成员没有默认类型，只知道成员的潜在类型足够大，肯定可以容纳所有枚举值。

可以通过在类型名的后面加上想要的类型来显式地指定 enum 成员的类型

```c++
enum uid:long long {first = 1242342745542, second = 63642652515};  // 枚举成员的类型为 long long
```

**枚举类型的前置声明**

可以提前声明 enum，但是不限定作用域的枚举类型在声明时必须指定成员类型。

enum 的声明和定义的成员类型必须匹配。

```c++
enum class Color1;    // 前置声明 Color1，成员类型默认为 int
enum uid:long long;   // 前置声明 uid，必须指定成员类型
```

## **19.4 类成员指针**

### **19.4.1 数据成员指针**

### **19.4.2 成员函数指针**

### **19.4.3 将成员函数用作可调用**



## **19.5 嵌套类**

一个类可以定义在另一个类的内部，称之为**嵌套类**。

嵌套类常用于定义作为实现部分的类。

嵌套类是一个独立的类，和外层类没什么关系。

嵌套类也使用访问限定符来控制外界对其成员的访问权限。外层类对嵌套类的成员没有特殊的访问权限。

注意：嵌套类实际上是在外层类中定义了一个新的类型，因此也属于**外层类的类型成员**，需要**先声明后使用**，外层类的成员也可以像使用任何其他类型成员一样使用嵌套类的名字。

**嵌套类的定义**

嵌套类**必须在类内进行声明**，但是可以定义在类内或类外。

在类外定义时，要加外层类作为访问限定符。定义嵌套类时，嵌套类可以直接使用外层类的成员，无需对该成员的名字进行限定。

```c++
class TextQuery::QueryResult{};
// 嵌套类在完成定义前，都是一个不完全类型。
// 定义嵌套类的成员函数和静态成员
TextQuery::QueryResult::Process(){};
int TextQuery::QueryReslut::data = 1024;
```

## **19.6 union:一种节省空间的类**

**联合**是一种特殊的类。一个联合可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。

当给 union 的某个成员赋值后，其他成员就变成**未定义**的状态了。

和其他类一样，一个 union 定义了一种新类型。

union 不能含有引用类型的成员，其他类型都可以。

默认情况下，union 的成员都是**公有的**，也可以为成员指定 public, protected, private 等标记。union 也可以定义成员函数，但不能定义虚函数。

**定义union类型**

union 用来定义一组类型不同的互斥值。

```c++
union Token{
    char cval;
    int ival;
    double dval;
}  // Token 类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种
```

**初始化union**

**默认情况下union 是未初始化的。**

可以使用花括号内的初始值来初始化一个 union，像聚合类一样。

提供的初始值被用于初始化 union 的**第一个成员**。

```c++
Token first_token = {'a'};//定义并初始化一个 Token 对象
Token *pt = new Token;//定义一个指向未初始化的 Token 对象的指针
```

**使用union**

使用通用的成员访问运算符来访问一个 union 对象的成员。

为 union 的一个数据成员赋值会令其他成员变为未定义状态。

**注意：不要使用错误的数据成员！会出现未知错误。**

```c++
first_token.ival = 2;
pt->dval = 1.2;
```

**匿名union**

匿名 union 是一个未命名的 union。当定义了一个匿名 union，编译器会自动为该 union 创建一个未命名对象。

匿名 union 的成员可以**在作用域内可以直接访问**。

```c++
union {
    char cval;
    int ival;
};
cval = 'c';//为上面定义的匿名 union 的对象赋值。
```

匿名 union 不能包含受保护成员或私有成员，也不能包含成员函数。

**含有类类型成员的union**

含有类类型成员的 union 的用法很复杂。它要运行类类型成员的构造函数、析构函数进行管理。

一般将含有类类型成员的 union 内嵌在另一个类中，使用该类来管理与 union 的类类型成员相关的操作。这时一般会将该 union 定义为匿名 union，并另外定义一个枚举类型来表示 union 的成员类型，定义一个枚举对象作为判别式来指明 union 当前已赋值的成员。

## **19.7 局部类**

定义在函数内部的类称为**局部类**。局部类的**成员都必须完整定义在类的内部**（比嵌套类严格的多）。

和嵌套类不同，局部类的成员受到严格限制。局部类中不能声明静态数据成员，因为没法定义（静态数据成员必须在类外定义）

**局部类的访问权限**

局部类可以访问外层作用域定义的类型名、静态变量和枚举成员，但不能访问外层函数的局部变量。

**嵌套的局部类**

局部类中可以再嵌套一个类，此时嵌套类的定义可以出现在局部类之外，不过必须定义在与局部类相同的作用域中。

局部类中的嵌套类也是一个局部类，必须遵循局部类的各种规定。

## **19.8 固有的不可移植的特性**

为了支持低层编程，C++ 定义了一些固有的不可移植的特性。

不可移植的特性即因机器而异的特性。将一个不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。

本节介绍的三个不可移植的特性：**位域、volatile 限定符、链接指示**。

### **19.8.1 位域**

类可以将它的非静态数据成员定义成位域，在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

位域在内存中的布局是与机器相关的。

位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以通常使用无符号类型保存一个位域。

位域的声明形式是在成员名字之后紧跟一个冒号及一个常量表达式，该表达式用于指定成员所占的二进制位数。

```c++
typedef unsigned int Bit;  // 定义类型别名 Bit，使位域看起来更突出
class File {
    Bit mode: 2;           // mode 占 2 位
    Bit modified: 1;       // modified 占 1 位
    Bit prot_owner: 3;
    Bit prot_group: 3;
    Bit prot_world: 3;
public:
    enum modes { READ = 01, WRITE = 02, EXECUTE = 03 };
    File& open(modes);
    void close();
    void write();
    bool isRead() const;
    void setWrite();
}
```

上面 5 个位域总共占 12 位，还不到一个 unsigned int 的长度。

如果可能的话，在类的内部连续定义的位域会压缩在同一整数的相邻位，从而提供存储压缩。如上例中，5 个位域可能会存储在同一个 unsigned int 中。

这些二进制位是否能够压缩到一个整数中及如何压缩是与机器相关的。

取地址运算符（&）无法作用于位域，所以任何指针都无法指向类的位域。

**使用位域**

访问位域的方式与方位其他数据成员的方式相似。

```c++
void File::write() {
    modified = 1;  //设置 modified 的值（modified 占 1 位）
    // ...
}
void File::close() {
    if(modified)
        // ...保存内容
}
```

通常使用内置的位运算符操作超过 1 位的位域。

```c++
File &File::open(File::modes m) {
    mode |= READ;   //按默认方式设置模式为 READ
    if(m & WRITE)   //如果打开模式为 READ 和 WRITE
        // ...
    return *this;    
}
```

如果一个类定义了位域成员，通常也会定义一组内联的成员函数来检验或设置位域的值

```c++
inline bool File::isRead() const { return mode& READ; }
inline void File::setWrite() { mode |= WRITE; }
```

### **19.8.2 volatile限定符**

关键字 volatile 告诉编译器不要对它所修饰的对象进行优化。

直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。

例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被改变时，应该将对象声明为 volatile。

**用法**

volatile 用法和 const 相似，也可以使用 volatile 修饰 const 对象。

```c++
volatile int display_register;   //该 int 值可能发生改变。
volatile Task *curr_task;        //curr_task 指向一个 volatile 对象
volatile int iax[max_size];      //数组的每个元素都是 volatile
volatile Screen bitmapBuf;       //bitmapBuf 的每个成员都是 volatile
```

也可以将成员函数定义为 volatile，只有 volatile 的成员函数才能被 volatile 的对象调用。

**volatile 指针和引用**

可以声明 volatile 指针、指向 volatile 对象的指针和指向 volatile 对象的 volatile 指针。

```c++
volatile int v;
int *volatile vip;
volatile int *ivp;
volatile int *volatile vivp;
int *ip = &v;
```

和 const 一样，只能将一个 volatile 对象的地址赋给一个指向 volatile 的指针。

同时只有当某个引用是 volatile 时，才能使用一个 volatile 对象初始化该引用。

理解：只有函数的参数类型是 volatile 引用时，它才能接受一个 volatile 对象。

**合成的拷贝对 volatile 对象无效**

不能使用合成的拷贝/移动构造函数及赋值运算符初始化 volatile 对象或从 volatile 对象赋值。

合成的成员接受的形参类型是非 volatile 的常量引用，显然不能将一个非 volatile 引用绑定到一个 volatile 对象上。

如果一个类希望拷贝、移动或赋值它的 volatile 对象，那它必须自定义拷贝或移动操作。例如可以将形参类型指定为 const volatile 引用。

```c++
class Foo {
public:
    Foo(const volatile Foo&);  // 从一个 volatile 对象进行拷贝
    Foo& operator=(const volatile Foo&);           // 将一个 volatile 对象赋值给一个非 volatile 对象
    Foo& operator=(const volatile Foo&) volatile;  // 将一个 volatile 对象赋值给一个 volatile 对象
}
```

### **19.8.3 链接指示:extern"C"**

C++ 程序有时需要调用其他语言编写的函数。像所有其他名字一样，其他语言中的函数名字也必须在 C++ 中进行**声明**，且该声明必须**指定返回类型和形参列表**。

对其他语言编写的函数来说，编译器检查其调用的方式与处理普通 C++ 函数的方式相同，但生成的代码有所区别。

C++ 使用**链接指示**指出任意非 C++ 函数所用的语言。

注意：要想把 C++ 代码和其他语言（包括 C 语言）编写那些的代码一起使用，必须有权访问该语言的编译器，且该编译器与当前的 C++ 编译器是兼容的。

**声明一个非 C++ 的函数**

链接指示有两种形式：单个的和复合的。

链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。

下面是 C++ 头文件  中可能出现的链接指示

```c++
extern "C" size_t strlen(const char *);       // 单语句链接指示
extern "C" {                                  // 复合语句链接指示
    int strcmp(const char*, const char*);
    char* strcat(char*, const char*);
}
```

链接指示包含一个关键字 extern 和一个字符串字面值常量，这个字符串指出了编写函数所用的语言。

编译器应该支持 **extern "C"**，此外还可能支持其他语言的链接指示，如 extern "FORTRAN" 等。

**链接指示与头文件**

复合语句声明的形式可以应用于整个头文件，这时整个头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。

```c++
extern "C" {
    #include <string.h>
}
```

**指向extern"C"函数的指针**